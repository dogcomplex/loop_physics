# --- knot_properties.py ---
# Module for defining the Knot object and calculating its invariants

# --- LSC Context & Future Directions ---
# This module calculates static topological invariants. A full physical model
# within Loop String Cosmology (LSC) or similar theories requires evolving beyond
# just the topological knot type (K) to capture physical states.
#
# Key Future Directions:
# 1. Explicit State Representation (Framed Knots):
#    - Define states using specific representations, e.g., using Braid Theory:
#      State = (KnotType=K, BraidIndex=n, BraidWord=b)
#      where 'K' is the topological type (e.g., 3_1), 'n' is the number of strands
#      (integer, n >= min_index(K)), and 'b' is the specific braid word
#      (discrete sequence of integers) whose closure yields K.
#    - Both 'n' and 'b' are discrete/quantized.
#    - Generate candidate states by iterating 'n' (starting from n_min) and
#      Braid Length L=len(b) up to a chosen L_max (e.g., L_max=20).
#    - Analyze all properties (writhe, diagram crossings, polys, etc.) derived
#      from the *specific* Link object generated by closing braid 'b'. This captures
#      representation-dependent nuances potentially corresponding to physical states
#      (ground state, excited states).
#
# 2. Dynamic Potential & Stability:
#    - Develop an effective potential V(representation) or V(n, b, f) that depends on the
#      specific representation (and likely physical framing 'f', perhaps related to writhe).
#    - Minima of V correspond to stable/metastable states (e.g., electron spin up/down).
#    - Non-minimal representations (higher L, different n, non-minimal |writhe|)
#      correspond to higher-energy excited states.
#    - Stability requires analyzing decay channels (topological transitions) governed by V.
#
# 3. Topological Transition Rules & Interaction Models:
#    - Define physical interaction rules based on topological operations that respect
#      conservation laws (charge, spin, etc.).
#    - Simple `connected_sum` (ignores structure) and `multiply_braids` (structure-dependent
#      but physically simplistic) are insufficient for accurate physical modeling.
#    - Need frameworks sensitive to the specific geometric/braid structure, such as:
#        - Tangle Calculus: Operating on knot diagrams with open ends.
#        - Skein Modules: Algebraic structures capturing diagram relations.
#
# 4. Dynamic Simulation Engine:
#    - Combine the state representation, potential V, and transition rules into a simulation
#      to model particle dynamics, interactions, and decays.
#
# The current 'stability_heuristic' primarily reflects topological structure
# (Prime, Composite, Link, Unknot) or identification status, not physical stability.
# Minimal representations (e.g., minimal L, minimal |writhe|) are hypothesized
# to be candidates for stable ground states.
# --- End LSC Context ---

import numpy as np
import math
import sys
import collections
import warnings # Import warnings module
import re

# Suppress specific DeprecationWarning from spherogram if desired
warnings.filterwarnings("ignore", category=DeprecationWarning, module="spherogram.links.invariants")

try:
    import spherogram
    import snappy # Often needed by spherogram for advanced features
    print("INFO: Spherogram & SnapPy libraries found.")
    
    # Check for Sage environment in a separate try block
    try:
        import sage.all
        # Test a simple Sage operation
        _ = sage.all.Integer(1) + sage.all.Integer(1)
        print("INFO: Running inside a functional SageMath environment.")
        SAGE_AVAILABLE = True
        # Define polynomial variables for Sage
        R = sage.all.LaurentPolynomialRing(sage.all.QQ, 'q_var')
        q_var = R.gen()
        T = sage.all.PolynomialRing(sage.all.ZZ, 't')
        t = T.gen()
        # Define roots of unity for evaluation
        ROOTS_OF_UNITY = {
            'w3': sage.all.exp(2 * sage.all.pi * sage.all.I / 3),
            'w4': sage.all.I, # exp(2*pi*i/4) = i
            'w5': sage.all.exp(2 * sage.all.pi * sage.all.I / 5),
            'w6': sage.all.exp(2 * sage.all.pi * sage.all.I / 6),
        }
    except ImportError:
        print("INFO: SageMath environment not available. Some polynomial calculations will be limited.")
        SAGE_AVAILABLE = False
        ROOTS_OF_UNITY = {}
        R = None
        q_var = None
        T = None
        t = None
finally:
    if 'SAGE_AVAILABLE' not in locals():
        SAGE_AVAILABLE = False
        ROOTS_OF_UNITY = {}
        R = None
        q_var = None
        T = None
        t = None


class KnotPropertyCalculator:
    """
    Encapsulates a knot or link and calculates its topological invariants.
    Uses spherogram and potentially snappy. Requires Sage for some polynomials.
    """
    def __init__(self, identifier, source_description="Unknown"):
        """
        Initializes Knot object from an identifier (e.g., '3_1', braid tuple).
        identifier: Standard knot name (str), braid word (str), or braid tuple (tuple).
        source_description: String describing how this knot was generated (e.g., 'Known', 'Braid(1,1,1)').
        """
        self.identifier = identifier
        self.source_description = source_description
        self.link_obj = None         # Raw spherogram Link object
        self.knot_obj = None         # Spherogram Knot object (if single component)
        self.manifold = None
        self.properties = {
            # Core Identifiers
            'input_identifier': identifier, # Keep track of original input
            'source_description': source_description,
            'knot_atlas_name': None, # Standard name like 3_1, L10a140 (best guess)
            # Basic Topology
            'components': None,
            'crossing_number_min': None, # Minimal crossing number from identification (unavailable)
            'signature': None,
            'determinant': None,
            'log_abs_determinant': None, # Log of absolute determinant
            'volume': None, # Hyperbolic volume
            # Diagrammatic Properties
            'writhe': None, # Diagrammatic writhe
            'morse_number': None, # Diagrammatic Morse number (optional calc)
            'is_alternating': None,
            # Chirality / Symmetry
            'is_chiral': None, # True if chiral, False if amphichiral (unavailable)
            # Structural Properties
            'is_torus': None, # Is it a torus knot? (Often heuristic based on volume/name)
            'is_fibered': None, # Is it fibered? (From basic checks, may be inaccurate)
            'is_fibered_hfk': None, # Is it fibered? (From HFK calculation, more robust, optional)
            'seifert_genus': None, # Seifert genus (From HFK calculation, optional)
            # Polynomials & Evaluations
            'alexander_poly': None, # Store polynomial object if possible
            'jones_poly': None,     # Store polynomial object if possible
            'alex_at_neg1': None,   # |Alexander(-1)| = Determinant (usually)
            'alex_at_neg2': None,   # Value of Alexander Polynomial at t=-2
            'jones_at_roots': {}, # Dict: {'w3': val, 'w4': val, ...}
            'log_abs_jones_at_roots': {}, # Dict: {'w3': val, 'w4': val, ...}
            # Representations
            'braid_word_repr': None, # Braid word representation (tuple/string)
            # --- LSC / Physics Placeholders (Require Dynamic Model) ---
            # Framing (f): Crucial state variable, related to spin/charge dynamics. Minimal |f| assumed stable.
            'framing_number': 'UNKNOWN', # Placeholder; needs explicit calculation/assignment based on physics model.
            # Topological Charge (Q): Should be conserved in interactions. Needs definition.
            'topological_charge_Q': 'UNKNOWN', # Mechanism needed. Placeholder.
            # Dynamics: Related to energy landscape V(x,f).
            'dynamic_stiffness_k': 'UNKNOWN', # Requires physics model V(x,f). Placeholder.
            'effective_inertia_m_eff': 'UNKNOWN', # Requires physics model V(x,f). Placeholder.
            # Stability Heuristic: Primarily topological decomposition. Physical stability depends on V(x,f) and decay channels.
            'stability_heuristic': 'Unknown', # e.g., 'Prime', 'Composite', 'Unknot', 'Link', 'Error'
        }
        self._calculate_properties()

    def _create_link_object(self):
        """Attempts to create a spherogram Link object from the identifier."""
        if self.link_obj: return True
        try:
            # Handle different identifier types
            if isinstance(self.identifier, tuple): # Braid Tuple
                print(f"Info: Creating Link from Braid tuple {self.identifier}")
                braid_list = [int(g) for g in self.identifier] # Ensure integers
                # Create Braid, then get its Link object
                braid_obj = spherogram.ClosedBraid(braid_list)
                # ClosedBraid is a subclass of Link, so assign it directly
                self.link_obj = braid_obj
                # Store the Knot object too if it's a knot
                try:
                    # Need num_components for ClosedBraid
                    num_comp = 1 # Default assumption
                    try:
                        # Use link_components attribute instead of num_components() method
                        num_comp = len(self.link_obj.link_components)
                    except AttributeError:
                         print(f"Warn: Could not access link_components on {type(self.link_obj)}. Assuming 1 component.")

                    if num_comp == 1:
                        self.knot_obj = braid_obj # Assign the braid obj directly as the knot obj
                    else:
                        self.knot_obj = None
                except Exception as e:
                    print(f"Warn: Error checking components/assigning knot_obj for braid {self.identifier}: {e}")
                self.properties['knot_atlas_name'] = f"Braid{self.identifier}" # Temporary name
                self.properties['source_description'] = f"Braid{self.identifier}"

            elif isinstance(self.identifier, str): # String Identifier (Name)
                # Special case for unknot
                if self.identifier == '0_1':
                    print("Info: Creating Unknot via Link([])")
                    self.link_obj = spherogram.Link([])
                    self.properties['knot_atlas_name'] = '0_1'
                    # Explicitly set knot_obj to None for unknot? Or create Knot([])?
                    # Let's assume Link([]) is sufficient for now.
                else:
                    # spherogram.Knot() is unavailable in this environment.
                    # Start with spherogram.Link()
                    try:
                        # Try spherogram.Link()
                        print(f"Info: Attempting spherogram.Link('{self.identifier}')")
                        self.link_obj = spherogram.Link(self.identifier)
                        print(f"Info: Successfully created Link object for '{self.identifier}' via Link().")
                        self.properties['knot_atlas_name'] = self.identifier
                        # Since we used Link(), knot_obj is likely None unless Link() returns a Knot subclass?
                        # We'll try the conversion later anyway.
                        self.knot_obj = None
                    except (ValueError, KeyError, Exception) as e_link:
                        print(f"Info: spherogram.Link('{self.identifier}') failed ({type(e_link).__name__}: {e_link}). Falling back to knot_db...")
                        try:
                            # Fallback: Try knot_db
                            print(f"Info: Attempting spherogram.knot_db['{self.identifier}']")
                            k_obj_db = spherogram.knot_db[self.identifier]
                            # Ensure we have a Link object for consistency
                            if isinstance(k_obj_db, spherogram.Link):
                                self.link_obj = k_obj_db
                                self.knot_obj = None # Might not be a knot
                            elif hasattr(k_obj_db, 'link'): # Check if it behaves like a Knot (has link method)
                                self.link_obj = k_obj_db.link()
                                # Can we assign it to knot_obj? Check if it has expected methods.
                                if hasattr(k_obj_db, 'identify'): # Heuristic check
                                    self.knot_obj = k_obj_db # Assume it's a knot object
                                else:
                                    self.knot_obj = None
                            else:
                                raise TypeError("Object from knot_db is not Link or Knot-like.")
                            self.properties['knot_atlas_name'] = self.identifier # Name is confirmed by db lookup
                            print(f"Info: Successfully loaded '{self.identifier}' from knot_db.")
                        except (KeyError, TypeError, AttributeError, Exception) as e_db:
                            print(f"ERROR: Identifier '{self.identifier}' not found via Link() or knot_db ({type(e_db).__name__}: {e_db}). Cannot create object.")
                            self.properties['stability_heuristic'] = 'Error'
                            return False
            else:
                print(f"ERROR: Invalid identifier type: {type(self.identifier)}")
                self.properties['stability_heuristic'] = 'Error'
                return False

            # Basic check after creation
            if self.link_obj is None:
                 print(f"ERROR: Link object creation resulted in None for '{self.identifier}'.")
                 self.properties['stability_heuristic'] = 'Error'
                 return False

            return True
        except ImportError:
             print("ERROR: Spherogram library not available for _create_link_object.")
             self.properties['stability_heuristic'] = 'Error'
             return False
        except Exception as e:
            print(f"ERROR: Failed during Link/Braid object creation for '{self.identifier}': {type(e).__name__} - {e}")
            self.properties['stability_heuristic'] = 'Error'
            return False

    def _calculate_properties(self):
        """Calculate standard topological invariants."""
        # --- Special case: Unknot --- #
        if self.identifier == '0_1':
            if not self.link_obj:
                # Attempt to create if not already done (should be done by __init__)
                if not self._create_link_object():
                     print("ERROR: Failed to create link object for unknot 0_1.")
                     self.properties['stability_heuristic'] = 'Error'
                     return

            props = self.properties
            print("Info: Setting properties for Unknot (0_1) directly.")
            props['knot_atlas_name'] = "0_1"
            props['stability_heuristic'] = 'Unknot'
            props['components'] = 1
            props['crossing_number_min'] = 0
            props['signature'] = 0
            props['determinant'] = 1
            props['log_abs_determinant'] = 0.0 # log(1)
            props['volume'] = 0.0
            props['is_alternating'] = True
            props['is_chiral'] = False
            props['is_torus'] = True
            props['is_fibered'] = True
            if SAGE_AVAILABLE:
                try:
                    props['alexander_poly'] = str(T(1)) # Alexander poly is 1
                except Exception:
                    props['alexander_poly'] = '1' # Fallback string
                try:
                    props['jones_poly'] = str(R(1)) # Jones poly is 1
                except Exception:
                    props['jones_poly'] = '1' # Fallback string
            else:
                props['alexander_poly'] = '1'
                props['jones_poly'] = '1'
            props['alex_at_neg1'] = 1
            props['alex_at_neg2'] = 1
            # Jones at roots of unity for J=1
            for name in ROOTS_OF_UNITY:
                props['jones_at_roots'][name] = 1.0
                props['log_abs_jones_at_roots'][name] = 0.0
            return # Finished with unknot

        # --- Proceed for non-Unknot cases --- #
        if not self._create_link_object():
            # props should be defined here if link creation failed
            props = self.properties # Ensure props is defined
            print(f"Skipping invariant calculation for '{self.identifier}' due to creation failure.")
            # Ensure stability heuristic reflects failure
            if props['stability_heuristic'] != 'Error':
                props['stability_heuristic'] = 'LinkCreationFailed'
            return # Stability heuristic already set in _create_link_object on error

        l = self.link_obj
        props = self.properties

        try:
            # Attempt to get number of components, handle potential AttributeError
            props['components'] = len(l.link_components)
        except AttributeError:
             print(f"Warn: 'link_components' attribute not found for {self.identifier}. Assuming 1.")
             props['components'] = 1 # Fallback assumption
        except Exception as e:
            print(f"Warn: Failed to get number of components for {self.identifier}: {type(e).__name__} - {e}")
            props['components'] = None # Mark as unknown

        # --- Handle Links vs Knots ---
        if props['components'] is None:
            props['stability_heuristic'] = 'ErrorCalculatingComponents'
            return # Cannot proceed
        elif props['components'] > 1:
            props['stability_heuristic'] = 'Link'
            # Try to get a link name (often complex, e.g., L10a140)
            try:
                # Identify may work differently for links, might return list of tuples
                ident_result = l.identify()
                if ident_result and isinstance(ident_result, list):
                     # Simple representation for now
                     props['knot_atlas_name'] = "Link:" + "_".join([spherogram.knot_db.name_from_tuple(comp) for comp in ident_result])
                else:
                     props['knot_atlas_name'] = f"Link ({props['components']} components)"
            except AttributeError:
                print(f"Warn: Link identification ('identify') not available for {self.identifier}.")
                props['knot_atlas_name'] = f"Link ({props['components']} components, unidentified)"
            except Exception as e:
                print(f"Warn: Link identification failed for {self.identifier}: {type(e).__name__} - {e}")
                props['knot_atlas_name'] = f"Link ({props['components']} components, identify error)"
            # Calculate some link properties if needed - focusing on knots for now
            return # Stop further knot-specific calculations
        elif props['components'] == 0:
             props['stability_heuristic'] = 'Empty'
             props['knot_atlas_name'] = "Empty"
             return # Stop

        # --- Single Component: Assume Knot ---
        # Try to convert to a Knot object for potentially more methods
        k = None # Initialize k to None
        try:
            # This might fail if the link isn't actually a knot or for other reasons
            # self.knot_obj = l.Knot() # Try converting to Knot object <--- REMOVE THIS LINE
            k = self.knot_obj
            print(f"Info: Successfully created Knot object for {self.identifier}")
        except AttributeError:
             print(f"Warn: Could not convert Link to Knot object for {self.identifier}. Using Link object directly.")
             k = l # Fallback to using the Link object 'l'
        except Exception as e:
             print(f"Warn: Error converting Link to Knot object for {self.identifier}: {type(e).__name__} - {e}. Using Link object.")
             k = l # Fallback

        # --- Knot Identification and Basic Properties ---
        try:
            ident_tuple_list = None
            manifold_for_id = None
            try:
                manifold_for_id = l.exterior() # Compute exterior first
                if manifold_for_id:
                    ident_tuple_list = manifold_for_id.identify()
                    print(f"Info: Identification successful via exterior() for {self.identifier}")
                else:
                    print(f"Warn: exterior() returned None for {self.identifier}, cannot identify.")
            except ImportError:
                print(f"Warn: Snappy/exterior() likely missing for identify() fallback {self.identifier}.")
            except AttributeError:
                 print(f"Warn: exterior() or identify() method missing for fallback {self.identifier}.")
            except Exception as e_ext_id:
                 # Catch specific SnapPy errors if needed, e.g., non-hyperbolic
                 print(f"Warn: Identification via exterior() failed for {self.identifier}: {type(e_ext_id).__name__} - {e_ext_id}")
                 ident_tuple_list = None # Ensure it's None on failure


            # --- Handle Identification Results (assuming identify() returns list of Manifold objects or tuples) ---
            # ---> START OF SECTION TO MODIFY <--- 
            # First, handle the case where identify() might return None or empty list
            if ident_tuple_list is None: # If exterior identification failed or wasn't possible
                 print(f"Warn: Identification failed for {self.identifier}. Treating as Unknown.")
                 props['knot_atlas_name'] = f"Unknown ({self.identifier}, Identify Failed)"
                 # Heuristic checks for stability
                 is_zero_vol = props.get('volume') is not None and np.isclose(props['volume'], 0.0, atol=1e-6)
                 is_braid_input = isinstance(self.identifier, tuple)
                 sig_known_nonzero = props.get('signature') is not None and props.get('signature') != 0
                 if is_zero_vol and is_braid_input and sig_known_nonzero:
                     props['stability_heuristic'] = 'PossibleTorusKnot'
                 else:
                     props['stability_heuristic'] = 'IdentifyFailed'
            # --- REPLACEMENT BLOCK START ---
            elif not ident_tuple_list: # Empty list returned by identify()
                 is_prime_by_input_fmt = False
                 if isinstance(self.identifier, str):
                     # Check for standard knot patterns like '3_1', 'K10a140' etc., EXCLUDING '0_1'
                     is_catalog_format = re.match(r'^(?!0_1$)\d+_\d+$', self.identifier) is not None or \
                                         re.match(r'^K\d+[an]\d+$', self.identifier) is not None # Add other formats if needed

                     if is_catalog_format:
                         # Input IS a standard knot name, but identify() failed. Trust input.
                         print(f"Info: identify() returned empty for {self.identifier}. Classified as Prime based on input format.")
                         props['knot_atlas_name'] = self.identifier  # Keep original name
                         props['stability_heuristic'] = 'Prime' # Classify as Prime
                         # Attempt to extract crossing number from the identifier itself
                         try:
                             match_cr = re.match(r'([LK]?)(\\d+)[a-z](\\d+)', self.identifier) or re.match(r'(\\d+)_(\\d+)', self.identifier)
                             if match_cr:
                                 group_idx = 2 if re.match(r'([LK]?)(\\d+)[a-z](\\d+)', self.identifier) else 1
                                 crossing_num = int(match_cr.group(group_idx))
                                 if crossing_num > 0:
                                     props['crossing_number_min'] = crossing_num
                             else: # Fallback for simple X_Y if regex fails
                                 crossing_num = int(self.identifier.split('_')[0])
                                 if crossing_num > 0:
                                     props['crossing_number_min'] = crossing_num
                         except:
                             pass # Keep None if parsing fails
                         is_prime_by_input_fmt = True

                 if not is_prime_by_input_fmt:
                     # Input is not standard format (or not string) AND identify() failed. Treat as Unknot.
                     print(f"Info: {self.identifier} treated as Unknot based on identify() returning empty and input not matching known catalog format.")
                     props['knot_atlas_name'] = "0_1"
                     props['stability_heuristic'] = 'Unknot'
                     # Explicitly set/overwrite main unknot properties
                     props['crossing_number_min'] = 0
                     props['signature'] = 0
                     props['determinant'] = 1
                     props['log_abs_determinant'] = 0.0
                     props['volume'] = 0.0
                     props['is_alternating'] = True
                     props['is_chiral'] = False
                     props['is_torus'] = True # Unknot is often considered torus
                     props['is_fibered'] = True # Unknot is fibered
                     if SAGE_AVAILABLE:
                         try: props['alexander_poly'] = str(T(1))
                         except Exception: props['alexander_poly'] = '1'
                         try: props['jones_poly'] = str(R(1))
                         except Exception: props['jones_poly'] = '1'
                     else:
                         props['alexander_poly'] = '1'
                         props['jones_poly'] = '1'
                     props['alex_at_neg1'] = 1
                     props['alex_at_neg2'] = 1
                     for name in ROOTS_OF_UNITY:
                         props['jones_at_roots'][name] = 1.0
                         props['log_abs_jones_at_roots'][name] = 0.0
            # --- REPLACEMENT BLOCK END ---
            # --- Handle Non-empty identification results ---
            else: # ident_tuple_list is not None and not empty
                try:
                    # ---> REFINED LOGIC START <--- 
                    identified_as_prime_by_input_match = False
                    # Check if input was a standard knot string (e.g., '4_1')
                    if isinstance(self.identifier, str):
                        input_is_std_knot_name = re.match(r'^(?!0_1$)\d+_\d+$', self.identifier) is not None or \
                                                 re.match(r'^K\d+[an]\d+$', self.identifier) is not None # Add K notation if needed
                        
                        if input_is_std_knot_name:
                            # Search the results for an exact match to the input identifier
                            for comp in ident_tuple_list:
                                comp_name = ""
                                if hasattr(comp, 'name'):
                                    comp_name = comp.name()
                                    if comp_name == self.identifier:
                                        # Found exact match! Prioritize this.
                                        props['knot_atlas_name'] = self.identifier
                                        # Extract crossing number from the standard name
                                        crossing_num = None
                                        match_cr = re.match(r'([LK]?)(\d+)[a-z](\d+)', comp_name) or re.match(r'(\d+)_(\d+)', comp_name)
                                        if match_cr:
                                             group_idx = 2 if re.match(r'([LK]?)(\d+)[a-z](\d+)', comp_name) else 1
                                             try: crossing_num = int(match_cr.group(group_idx))
                                             except: pass
                                        if crossing_num is not None:
                                            props['crossing_number_min'] = crossing_num
                                        else: # Fallback: parse from input string if possible
                                            try:
                                                crossing_num = int(self.identifier.split('_')[0]) # Assumes X_Y format
                                                if crossing_num > 0: props['crossing_number_min'] = crossing_num
                                            except: pass
                                            
                                        props['stability_heuristic'] = 'Prime'
                                        identified_as_prime_by_input_match = True
                                        print(f"Info: Identified as Prime Knot: {self.identifier} (matching input against identify() results).")
                                        break # Stop searching once match found
                                elif isinstance(comp, tuple): # Handle tuple case if needed (less likely for exact match)
                                    pass 
                    
                    # If not identified as prime by matching input, proceed with previous logic
                    if not identified_as_prime_by_input_match:
                        # ---> ORIGINAL LOGIC (slightly adapted) <--- 
                        first_comp = ident_tuple_list[0]
                        first_comp_name = "Unknown"
                        first_crossing_num_match = None
                        valid_name_found = False # Is the first name standard? 

                        if hasattr(first_comp, 'name'):
                            first_comp_name = first_comp.name()
                            match_std_pattern = re.match(r'^([LK]?)(\d+)[a-z](\d+)$|^(\d+)_(\d+)$|^K\d+[an]\d+$', first_comp_name)
                            match_unknot = (first_comp_name == '0_1')
                            
                            if match_std_pattern and not match_unknot:
                                valid_name_found = True
                                match_cr = re.match(r'([LK]?)(\d+)[a-z](\d+)', first_comp_name) or re.match(r'(\d+)_(\d+)', first_comp_name)
                                if match_cr:
                                     group_idx = 2 if re.match(r'([LK]?)(\d+)[a-z](\d+)', first_comp_name) else 1
                                     try: first_crossing_num_match = int(match_cr.group(group_idx))
                                     except: pass
                            elif match_unknot:
                                valid_name_found = True
                                first_crossing_num_match = 0
                                
                        elif isinstance(first_comp, tuple) and len(first_comp) == 2 and isinstance(first_comp[0], int):
                            first_comp_name = f"Tuple{first_comp}"
                            valid_name_found = False 
                            if first_comp[0] > 0: first_crossing_num_match = first_comp[0]
                        else:
                            first_comp_name = f"UnknownType({type(first_comp).__name__})"
                            valid_name_found = False

                        # Decide heuristic based on the *first* identification result if input wasn't matched
                        if valid_name_found and first_comp_name != "0_1":
                            # First result IS a standard prime knot name
                            props['knot_atlas_name'] = first_comp_name
                            props['crossing_number_min'] = first_crossing_num_match
                            props['stability_heuristic'] = 'Prime'
                            print(f"Info: Identified as Prime Knot: {first_comp_name} (using first result from identify(); input mismatch or not standard).")
                        elif valid_name_found and first_comp_name == "0_1":
                            # First result IS unknot
                            props['knot_atlas_name'] = "0_1"
                            props['stability_heuristic'] = 'Unknot'
                            props['crossing_number_min'] = 0
                            props['signature'] = 0
                            props['determinant'] = 1
                            props['volume'] = 0.0
                            print(f"Info: Identified as Unknot: {first_comp_name} (using first result from identify(); input mismatch or not standard).")
                        elif len(ident_tuple_list) > 1:
                             # First result wasn't standard prime/unknot, AND there are multiple results.
                             # Treat as CompositeByIdentify.
                             all_names = []
                             all_crossing_nums = []
                             for comp in ident_tuple_list:
                                 comp_name = "Unknown"
                                 cn = None
                                 if hasattr(comp, 'name'): 
                                     comp_name = comp.name()
                                     match = re.match(r'([LK]?)(\d+)[a-z](\d+)', comp_name) or re.match(r'(\d+)_(\d+)', comp_name)
                                     if match:
                                         group_idx = 2 if re.match(r'([LK]?)(\d+)[a-z](\d+)', comp_name) else 1
                                         try: cn = int(match.group(group_idx))
                                         except: pass
                                 elif isinstance(comp, tuple): 
                                     comp_name = f"Tuple{comp}"
                                     if len(comp)==2 and isinstance(comp[0], int) and comp[0] > 0: cn = comp[0]
                                 else: comp_name = f"UnknownType({type(comp).__name__})"
                                 all_names.append(comp_name)
                                 if cn is not None: all_crossing_nums.append(cn)
                                 
                             props['knot_atlas_name'] = " # ".join(all_names)
                             props['stability_heuristic'] = 'CompositeByIdentify'
                             if len(all_crossing_nums) == len(ident_tuple_list):
                                 props['crossing_number_min'] = sum(all_crossing_nums)
                             print(f"Info: Classified as CompositeByIdentify: {props['knot_atlas_name']}.")
                        else:
                            # Single, non-standard, non-unknot result
                            props['knot_atlas_name'] = f"Unknown ({first_comp_name})"
                            props['stability_heuristic'] = 'UnknownPrime'
                            if first_crossing_num_match is not None:
                                props['crossing_number_min'] = first_crossing_num_match
                            print(f"Info: Identified as Unknown/Non-standard: {props['knot_atlas_name']}.")

                except Exception as e_name_extract:
                    # Catch errors during the processing of non-empty list
                    print(f"Warn: Error processing identification result {ident_tuple_list} for {self.identifier}: {type(e_name_extract).__name__} - {e_name_extract}")
                    props['knot_atlas_name'] = f"Unknown ({self.identifier}, NameExtractError)"
                    props['stability_heuristic'] = 'IdentifyError'
            # ---> END OF SECTION TO MODIFY <--- 

        except AttributeError as e_attr: # Catch attribute errors if exterior() or identify() missing
            print(f"Warn: Knot identification attribute error for {self.identifier}: {e_attr}. Status Unknown.")
            if props.get('stability_heuristic') not in ['IdentifyFailed', 'IdentifyError', 'IdentifyAttrError', 'UnknownPrime', 'Unknot', 'PossibleTorusKnot']:
                 props['stability_heuristic'] = 'IdentifyAttrError'
        except Exception as e: # Catch other identification errors
            print(f"Warn: Knot identification failed unexpectedly for {self.identifier}: {type(e).__name__} - {e}")
            if props.get('stability_heuristic') not in ['IdentifyFailed', 'IdentifyError', 'IdentifyAttrError', 'UnknownPrime', 'Unknot', 'PossibleTorusKnot']:
                props['stability_heuristic'] = 'IdentifyError'
                
        # --- Calculate other invariants (use object 'l') ---
        calc_obj = l # Use Link object

        # --- Re-check for Unknot after all identification attempts ---
        if props['stability_heuristic'] == 'Unknot':
             # Most properties should be set, but ensure key ones are correct
             # This avoids running expensive calculations below for the unknot
             if props.get('determinant') is None: props['determinant'] = 1
             if props.get('alex_at_neg1') is None: props['alex_at_neg1'] = 1
             # ... maybe add others if needed ...
             pass # Continue to maybe calculate things like writhe if desired? Or return? Let's allow writhe etc.

        # --- Proceed with calculations ONLY if not identified as Unknot ---
        if props['stability_heuristic'] != 'Unknot':
            # Basic Invariants
            try:
                props['signature'] = calc_obj.signature()
            except AttributeError:
                print(f"Warn: 'signature' method not found for {self.identifier}.")
            except ImportError:
                print(f"Warn: Signature calc failed (likely missing SnapPy/Sage) for {self.identifier}.")
            except Exception as e:
                print(f"Warn: Signature calc failed for {self.identifier}: {type(e).__name__} - {e}")

            try:
                det = calc_obj.determinant()
                # Spherogram determinant() often returns rational, ensure it's int for knots
                if SAGE_AVAILABLE and hasattr(sage, 'all') and isinstance(det, sage.all.Rational):
                    if det.denominator() == 1:
                        det = det.numerator()
                    else: # Should not happen for knot determinant, but handle anyway
                         print(f"Warn: Non-integer determinant {det} for {self.identifier}. Using numerator.")
                         det = det.numerator()
                # Convert potential Sage Integer to Python int
                try:
                    det = int(det)
                except TypeError:
                    print(f"Warn: Could not convert determinant {det} (type: {type(det)}) to int directly.")
                    det = None # Mark as failed

                if det is not None:
                    props['determinant'] = abs(det) # Determinant is usually positive integer
                    if props['determinant'] is not None and props['determinant'] > 0:
                        props['log_abs_determinant'] = np.log(props['determinant'])
                    elif props['determinant'] == 0 : # Should not happen for knots other than unknot?
                        props['log_abs_determinant'] = -np.inf
                else:
                     props['determinant'] = None
                     props['log_abs_determinant'] = None

            except AttributeError: print(f"Warn: 'determinant' method not found for {self.identifier}.")
            except ImportError: print(f"Warn: Determinant calc failed (likely missing SnapPy/Sage) for {self.identifier}.")
            except Exception as e: print(f"Warn: Determinant calc failed for {self.identifier}: {type(e).__name__} - {e}")

            # Diagrammatic Properties
            try:
                props['is_alternating'] = calc_obj.is_alternating()
            except AttributeError:
                print(f"Warn: 'is_alternating' method not found for {self.identifier}.")
            except Exception as e:
                print(f"Warn: Alternating check failed: {type(e).__name__} - {e}")

            try:
                props['writhe'] = calc_obj.writhe()
            except AttributeError:
                print(f"Warn: 'writhe' method not found for {self.identifier}.")
            except Exception as e:
                print(f"Warn: Writhe calculation failed: {type(e).__name__} - {e}")

            # Chirality (method known to be missing)
            try:
                # This will likely fail based on previous runs, but keep for completeness
                props['is_chiral'] = not calc_obj.is_amphichiral()
            except AttributeError: pass # Expected failure
            except Exception as e: print(f"Warn: Chirality check failed: {type(e).__name__} - {e}")

            # Fibering (basic check)
            try:
                props['is_fibered'] = calc_obj.is_fibered()
            except AttributeError: pass # Method might not exist depending on version/backend
            except NotImplementedError: pass # Some knots might not have this implemented
            except Exception as e: print(f"Warn: Fibered check (basic) failed: {type(e).__name__} - {e}")

        # --- Manifold Properties (using SnapPy via Spherogram) ---
        try:
            # Use exterior() on the original link object 'l' might be safer
            # Reuse manifold_for_id if calculated during identification
            manifold_to_use = manifold_for_id if 'manifold_for_id' in locals() and manifold_for_id else l.exterior()

            if manifold_to_use:
                self.manifold = manifold_to_use # Store it
                vol = self.manifold.volume() # Indentation corrected
                # SnapPy volume can return complex with zero imaginary part, take real
                try:
                    # Directly convert Sage RealNumber (or other numeric types) to float
                    props['volume'] = float(vol)
                except TypeError:
                    # Fallback if direct conversion fails (shouldn't happen for RealNumber, but be safe)
                    print(f"Warn: Direct float(vol) failed for {self.identifier}. Type was {type(vol)}. Trying vol.real.")
                    props['volume'] = float(vol.real) if hasattr(vol, 'real') else None
                except Exception as e_vol_conv:
                     print(f"Warn: Exception during volume float conversion for {self.identifier}: {e_vol_conv}")
                     props['volume'] = None
            else:
                 # Handle case where exterior() failed or returned None
                 props['volume'] = None
                 print(f"Info: Could not obtain manifold for volume calculation for {self.identifier}.")

            # Check if Torus based on volume (heuristic) & name
            # Only apply heuristic if volume is near zero AND it wasn't identified as unknot
            is_zero_vol = False # Default to False
            if props.get('volume') is not None: # Check if volume calculation succeeded
                is_zero_vol = np.isclose(props['volume'], 0.0, atol=1e-6)
            is_unknot = props['stability_heuristic'] == 'Unknot'
            # Torus if volume is zero AND not unknot
            props['is_torus'] = is_zero_vol and not is_unknot

        except ImportError: # Indentation Corrected
            print(f"Info: SnapPy/exterior() not available for volume calc {self.identifier}.")
            props['volume'] = None # Ensure volume is None
            props['is_torus'] = None # Can't determine torus status
        except AttributeError: # Indentation Corrected
            print(f"Info: exterior() or volume() method not available for {self.identifier}.")
            props['volume'] = None
            props['is_torus'] = None
        except Exception as e:
            # Don't warn if volume is just zero (common for torus knots)
            current_vol = props.get('volume') # Get volume *after* potential assignment/error
            is_likely_zero = ('Manifold has zero volume' in str(e) or
                              (isinstance(current_vol, (float, int)) and np.isclose(current_vol, 0.0)))
            if not is_likely_zero:
                 print(f"Warn: Manifold/Volume calc failed for {self.identifier}: {type(e).__name__} - {e}")
            # Ensure volume is None if calculation truly failed, but keep 0.0 if that was the result
            if props.get('volume') is None: # If it never got set correctly in try block
                props['volume'] = None
                props['is_torus'] = None # Set torus to None if volume failed

        # --- Polynomial Calculations (Requires Sage) ---
        if SAGE_AVAILABLE:
            # Skip polynomials for unknot if already set by identification logic
            if props['stability_heuristic'] != 'Unknot' or props.get('jones_poly') is None:
                # Jones Polynomial
                try:
                    # Ensure we have a variable 'q_var' for Jones
                    # Use R = sage.all.LaurentPolynomialRing(sage.all.QQ, 'q_var') and q_var = R.gen() defined globally
                    if R is None or q_var is None:
                         raise ValueError("Sage LaurentPolynomialRing 'R' or generator 'q_var' not available.")

                    jones_poly_q = calc_obj.jones_polynomial(variable=q_var)
                    props['jones_poly'] = str(jones_poly_q) # Store as string
                    # Evaluate at roots of unity
                    for name, root in ROOTS_OF_UNITY.items(): # Indentation Corrected
                        try: # Indentation Corrected
                            jones_eval = jones_poly_q(root)
                            # Handle potential complex results: take absolute value (magnitude)
                            # Convert Sage complex number to float before abs if needed
                            if hasattr(jones_eval, 'abs'): # Indentation Corrected
                                jones_abs = jones_eval.abs() # Use Sage's abs() for complex
                            else:
                                # Try converting to complex first, then abs
                                try:
                                    jones_abs = abs(complex(jones_eval))
                                except Exception:
                                     print(f"Warn: Could not convert Jones eval result ({type(jones_eval)}) to complex for abs().")
                                     jones_abs = None # Mark as failed

                            if jones_abs is not None:
                                props['jones_at_roots'][name] = float(jones_abs)
                                # Calculate log only if abs value is significantly non-zero
                                if jones_abs > 1e-9: # Indentation Corrected
                                    props['log_abs_jones_at_roots'][name] = float(np.log(jones_abs))
                                else:
                                    props['log_abs_jones_at_roots'][name] = -np.inf # log(0) -> -inf
                            else:
                                props['jones_at_roots'][name] = None
                                props['log_abs_jones_at_roots'][name] = None

                        except TypeError as te: # Indentation Corrected
                             # Can happen if polynomial eval fails for a root
                             print(f"Warn: Jones eval failed for root '{name}' on {self.identifier}: {te}") # Indentation Corrected
                             props['jones_at_roots'][name] = None
                             props['log_abs_jones_at_roots'][name] = None
                        except Exception as e_eval: # Indentation Corrected
                             print(f"Warn: Jones eval failed unexpectedly for root '{name}' on {self.identifier}: {type(e_eval).__name__} - {e_eval}") # Indentation Corrected
                             props['jones_at_roots'][name] = None
                             props['log_abs_jones_at_roots'][name] = None
                except AttributeError: # Indentation Corrected
                    print(f"Warn: 'jones_polynomial' method not found for {self.identifier}.")
                except ImportError: # Indentation Corrected
                    print(f"Warn: Jones calc failed (likely missing SnapPy/Sage) for {self.identifier}.")
                except Exception as e_jones: # Indentation Corrected
                    print(f"Warn: Jones Polynomial calculation failed for {self.identifier}: {type(e_jones).__name__} - {e_jones}") # Indentation Corrected

                # Alexander Polynomial
                # Skip Alexander for unknot if already set by identification logic
                if props['stability_heuristic'] != 'Unknot' or props.get('alexander_poly') is None:
                    try:
                        # Use calc_obj (which is l)
                        alex_poly_raw = calc_obj.alexander_polynomial()

                        # Ensure t is available (defined globally)
                        if t is None:
                             raise ValueError("Sage PolynomialRing generator 't' not available.")

                        # Convert to Sage Polynomial in variable t if possible and needed
                        alex_poly_t = None # Initialize
                        if SAGE_AVAILABLE and alex_poly_raw is not None and t is not None:
                            try:
                                # Check if raw result is suitable for univariate T(t) ring
                                is_likely_univariate = False
                                if isinstance(alex_poly_raw, (int, float)):
                                    is_likely_univariate = True
                                elif hasattr(alex_poly_raw, 'variables'):
                                    vars_in_poly = alex_poly_raw.variables()
                                    if not vars_in_poly or vars_in_poly == (t,):
                                        is_likely_univariate = True
                                elif isinstance(alex_poly_raw, str):
                                    # Improved check for simple t-polynomials
                                    # Allow digits, t, +, -, *, ^, spaces, and parentheses for exponents
                                    if re.fullmatch(r"[\\d\\s\\+\\-\\*\\^t\\(\\)]*", alex_poly_raw):
                                         # Check if only 't' is the variable (or no variable for constants)
                                         vars_in_str = set(re.findall(r"[a-zA-Z]+", alex_poly_raw))
                                         if not vars_in_str or vars_in_str == {'t'}:
                                             is_likely_univariate = True
                                    elif alex_poly_raw.isdigit() or (alex_poly_raw.startswith('-') and alex_poly_raw[1:].isdigit()):
                                         is_likely_univariate = True # Handle constants like "-5"

                                if is_likely_univariate:
                                    # Attempt conversion to the polynomial ring T(variable=t)
                                    # Check if t is defined
                                    if t is None:
                                         print(f"Warn: Cannot convert Alexander poly for {self.identifier}, Sage variable 't' is not defined.")
                                         alex_poly_t = None # Mark as non-Sage polynomial
                                         # Store raw string if available
                                         props['alexander_poly'] = str(alex_poly_raw) if alex_poly_raw is not None else None
                                    else:
                                         alex_poly_t = T(alex_poly_raw)
                                         props['alexander_poly'] = str(alex_poly_t) # Store Sage string rep
                                else:
                                    print(f"Info: Alexander result for {self.identifier} appears multivariate or non-convertible to T(t). Storing as string: {alex_poly_raw}")
                                    props['alexander_poly'] = str(alex_poly_raw) # Store raw string
                                    alex_poly_t = None # Mark as non-Sage polynomial

                            except Exception as e_conv:
                                print(f"Warn: Could not convert Alexander result ({alex_poly_raw}) to Sage polynomial T(t): {e_conv}")
                                # Store raw string on error only if it's not None already
                                if alex_poly_raw is not None:
                                    props['alexander_poly'] = str(alex_poly_raw)
                                else:
                                    props['alexander_poly'] = None # Ensure it's None if raw was None
                                alex_poly_t = None # Failed conversion
                        else:
                            # If not using Sage, or raw result was None, or conversion failed, or t is None
                            if alex_poly_raw is not None: # Check if alex_poly_raw is None
                                props['alexander_poly'] = str(alex_poly_raw) # Store string rep if not None
                                alex_poly_t = None # Indicate not a usable Sage polynomial
                            else: # alex_poly_raw is None
                                props['alexander_poly'] = None
                                alex_poly_t = None


                        # Process alex_poly_t ONLY if it's a valid Sage polynomial in T(t)
                        if alex_poly_t is not None and hasattr(alex_poly_t, 'parent') and alex_poly_t.parent() == T:
                             if alex_poly_t.is_zero():
                                 # Alexander poly is 0 for split links, but shouldn't be for knots (unless unknot?)
                                 print(f"Info: Alexander polynomial is zero for {self.identifier}.")
                                 # props['alexander_poly'] is already "0" or str(poly) from above
                                 props['alex_at_neg1'] = 0
                                 props['alex_at_neg2'] = 0
                             else:
                                 # props['alexander_poly'] already set to str(alex_poly_t)
                                 try:
                                     val_neg1 = alex_poly_t(-1)
                                     # Ensure integer result if possible
                                     props['alex_at_neg1'] = abs(int(val_neg1)) if hasattr(val_neg1, 'is_integer') and val_neg1.is_integer() else abs(float(val_neg1))
                                 except Exception as e_alex1: print(f"Warn: Alex(-1) eval failed: {e_alex1}")

                                 try:
                                     val_neg2 = alex_poly_t(-2)
                                     props['alex_at_neg2'] = abs(int(val_neg2)) if hasattr(val_neg2, 'is_integer') and val_neg2.is_integer() else abs(float(val_neg2))
                                 except Exception as e_alex2: print(f"Warn: Alex(-2) eval failed: {e_alex2}")
                        else:
                            # If alex_poly_t is None (conversion failed or not attempted),
                            # alex_at_neg1/2 should remain None (their default)
                            # props['alexander_poly'] should already be set to str(raw) or None.
                            if props.get('alexander_poly') is None:
                                 print(f"Info: Alexander polynomial result was None for {self.identifier}.")

                    except AttributeError:
                        print(f"Warn: 'alexander_polynomial' method not found for {self.identifier}.")
                    except ImportError:
                        print(f"Warn: Alexander calc failed (likely missing SnapPy/Sage) for {self.identifier}.")
                    except Exception as e_alex:
                        print(f"Warn: Alexander Polynomial calculation failed for {self.identifier}: {type(e_alex).__name__} - {e_alex}")

        # Final check: if determinant was calculated and alex_at_neg1 was calculated, they should match for a knot.
        # Only perform this check if NOT explicitly an unknot (where Alex(-1) is trivially 1)
        # and if the Alexander polynomial wasn't determined to be multivariate.
        alex_poly_str = props.get('alexander_poly')
        is_likely_multivar_alex = alex_poly_str is not None and any(v in alex_poly_str for v in ['t1', 't2', 't3']) # Basic check

        if props['stability_heuristic'] != 'Unknot' and not is_likely_multivar_alex:
            det_prop = props.get('determinant')
            alex1_prop = props.get('alex_at_neg1')
            # Check only if both are valid numbers
            if isinstance(det_prop, (int, float)) and isinstance(alex1_prop, (int, float)):
                if not np.isclose(float(det_prop), float(alex1_prop)):
                     print(f"Warn: Determinant ({det_prop}) and |Alexander(-1)| ({alex1_prop}) mismatch for {self.identifier}.")
            elif det_prop is not None and alex1_prop is not None:
                 # Avoid warning if evaluation failed for Alex(-1) or determinant calc failed
                 pass
        elif is_likely_multivar_alex:
             # If alex is multivariate, alex_at_neg1 should be None, no check needed
             pass

        # --- Other Representations and Optional Calculations ---
        if props['stability_heuristic'] != 'Unknot':
            # Braid Word
            try:
                # If the identifier was already a braid tuple, use it directly
                if isinstance(self.identifier, tuple):
                     props['braid_word_repr'] = self.identifier
                else:
                    # Otherwise, try calculating it from the Link/Knot object
                    braid_word = calc_obj.braid_word()
                    # Store as tuple of integers for potential later use
                    props['braid_word_repr'] = tuple(braid_word)
            except AttributeError:
                print(f"Warn: 'braid_word' method not found for {self.identifier}.")
            except Exception as e:
                print(f"Warn: Braid word calculation failed: {type(e).__name__} - {e}")

            # Morse Number (Optional)
            try:
                print(f"DEBUG: Attempting Morse number calculation for {self.identifier}...") # Debug print
                props['morse_number'] = calc_obj.morse_number()
                print(f"DEBUG: Morse number calculation finished for {self.identifier}.") # Debug print
            except AttributeError: pass # Morse number method might not exist
            except ImportError: pass # May depend on external solver like GLPK
            except KeyboardInterrupt:
                print(f"Warn: Morse number calculation interrupted for {self.identifier}.")
                props['morse_number'] = None # Set to None if interrupted
            except Exception as e:
                # Avoid verbose warnings for optional calcs unless clearly an error
                if 'GLPK' not in str(e) and 'CBC' not in str(e):
                     print(f"Warn: Morse number calculation failed: {type(e).__name__} - {e}")
                props['morse_number'] = None # Ensure it's None on failure

            # Knot Floer Homology (Optional - requires external HFKCalculator)
            try:
                # Only run HFK if it's identified as a single prime knot
                if props.get('stability_heuristic') == 'Prime':
                    print(f"Info: Attempting Knot Floer Homology for {self.identifier}...") # Info print
                    hfk_calc_obj = k if k else l # Revisit this - does HFK work on Link?
                    hfk_results = hfk_calc_obj.knot_floer_homology()
                    if isinstance(hfk_results, dict):
                        props['seifert_genus'] = hfk_results.get('seifert_genus')
                        props['is_fibered_hfk'] = hfk_results.get('fibered')
                        # Could store total_rank or rank details if needed
                        # props['hfk_total_rank'] = hfk_results.get('total_rank')
                    else:
                         print(f"Warn: HFK result was not a dictionary for {self.identifier}: {hfk_results}")
                elif props.get('stability_heuristic') not in ['IdentifyFailed', 'IdentifyError', 'IdentifyAttrError', 'UnknownPrime', 'Unknot', 'LinkCreationFailed', 'ErrorCalculatingComponents', 'Empty', 'Link']:
                    # Only print skip message if identification didn't fail AND it's a single component
                    print(f"Info: Skipping HFK for {self.identifier} (heuristic: {props.get('stability_heuristic')}).")

            except ImportError:
                # Usually means HFKCalculator command is not found
                print("Info: Knot Floer Homology calculation skipped (requires external HFKCalculator).")
                pass
            except FileNotFoundError:
                 print("Info: Knot Floer Homology calculation skipped (HFKCalculator command not found in PATH).")
                 pass
            except AttributeError:
                 print(f"Warn: 'knot_floer_homology' method not found for {self.identifier}.")
                 pass
            except Exception as e:
                # Avoid printing error for every knot if tool is just missing
                if 'HFKCalculator' not in str(e):
                    print(f"Warn: Knot Floer Homology calculation failed: {type(e).__name__} - {e}")

    def get_property(self, prop_name):
        return self.properties.get(prop_name, None)

    def report(self):
        """Prints a formatted report of the calculated properties."""
        # Use the most definitive name available
        display_name = self.properties.get('knot_atlas_name') or self.properties.get('input_identifier', 'N/A')
        print(f"\n--- Properties for Knot/Link: {display_name} ---")
        if self.properties.get('input_identifier') != display_name and self.properties.get('knot_atlas_name'):
             print(f"  (Input Identifier: {self.properties.get('input_identifier')})")
        if self.properties.get('source_description') != 'Unknown':
            print(f"  (Source: {self.properties.get('source_description')})")

        # Define order or skip certain keys if needed
        skip_keys = {'input_identifier', 'source_description', 'knot_atlas_name'}
        key_order = [
            # Core ID & Topology
            'stability_heuristic', 'components', 'crossing_number_min',
            'signature', 'determinant', 'log_abs_determinant', 'volume',
            # Diagrammatic
            'writhe', 'morse_number', 'is_alternating',
            # Structure
            'is_chiral', 'is_torus', 'is_fibered', 'is_fibered_hfk', 'seifert_genus',
            # Polynomials & Evaluations
            'alexander_poly', 'jones_poly',
            'alex_at_neg1', 'alex_at_neg2', 'jones_at_roots', 'log_abs_jones_at_roots',
            # Representations
            'braid_word_repr',
            # Properties needing more theoretical definition / postulates
            'framing_number', 'topological_charge_Q', 'dynamic_stiffness_k', 'effective_inertia_m_eff'
        ]

        reported_keys = set()

        for key in key_order:
             if key in self.properties and key not in skip_keys:
                 value = self.properties[key]
                 if value == 'UNKNOWN': continue # Skip placeholders explicitly marked
                 if value is None:
                      print(f"  {key:<22}: None")
                 elif isinstance(value, float) or isinstance(value, np.floating):
                      # Handle potential infinities from logs
                      if np.isinf(value):
                          print(f"  {key:<22}: {value}") # Print inf or -inf directly
                      else:
                          print(f"  {key:<22}: {value:.5f}") # More precision for floats
                 elif isinstance(value, dict):
                     print(f"  {key:<22}:")
                     if not value:
                         print("    (empty)")
                     else:
                         for k, v in sorted(value.items()): # Sort dict items for consistent output
                             if v is None:
                                  print(f"    {k}: None")
                             elif isinstance(v, float) or isinstance(v, np.floating):
                                 if np.isinf(v):
                                     print(f"    {k}: {v}")
                                 else:
                                     print(f"    {k}: {v:.5f}")
                             else:
                                  print(f"    {k}: {v}")
                 elif isinstance(value, str) and len(value) > 60: # Truncate long strings (like polynomials)
                     print(f"  {key:<22}: {value[:57]}...")
                 else:
                      print(f"  {key:<22}: {value}")
                 reported_keys.add(key)

        # Report any remaining properties not in the defined order
        print("  --- Other Properties ---")
        other_keys = set(self.properties.keys()) - reported_keys - skip_keys
        if not other_keys:
            print("    (None)")
        else:
            for key in sorted(list(other_keys)):
                value = self.properties[key]
                if value == 'UNKNOWN': continue
                # Basic print for other keys
                print(f"  {key:<22}: {value}")

        print("-" * 35)

# --- knot_interactions.py ---
# Module for simulating knot interactions (Connected Sum)

def connected_sum(knot_calc1, knot_calc2):
    """
    Performs connected sum conceptually and calculates invariants of result.
    Uses known ADDITIVE/MULTIPLICATIVE properties where possible.

    LIMITATIONS (Physical Context):
    - This is a purely mathematical operation (cutting and rejoining strands).
    - It ignores crucial physical aspects:
        - Dynamics & Energy: Doesn't account for interaction energy or stability.
        - Framing (f): Ignores the framing state of the knots, vital for spin/dynamics.
        - Braid Representation: The result is independent of the specific braid used.
        - Physical Realizability: Assumes the operation is physically possible.
    - The resulting properties are estimates based on topological rules, not a simulation
      of a physical collision or binding. Useful for tracking topological additivity/multiplicativity
      but not predictive of interaction outcomes or reaction rates.
    """
    k1_name = knot_calc1.get_property('knot_atlas_name') or knot_calc1.identifier
    k2_name = knot_calc2.get_property('knot_atlas_name') or knot_calc2.identifier
    print(f"\n--- Simulating Connected Sum: {k1_name} # {k2_name} ---")

    # Basic check: Ensure inputs are single-component knots
    if knot_calc1.get_property('components') != 1 or knot_calc2.get_property('components') != 1:
        print("ERROR: Connected sum is typically defined for knots (1 component).")
        print(f"  (Components: {knot_calc1.get_property('components')}, {knot_calc2.get_property('components')})")
        return None
    # Ensure inputs aren't unknots (sum with unknot is the original knot)
    if knot_calc1.get_property('stability_heuristic') == 'Unknot':
        print("Info: Connected sum with Unknot results in the other knot.")
        return knot_calc2.properties.copy()
    if knot_calc2.get_property('stability_heuristic') == 'Unknot':
        print("Info: Connected sum with Unknot results in the other knot.")
        return knot_calc1.properties.copy()

    result_name = f"{k1_name} # {k2_name}"
    # Initialize result props based on k1, then update
    result_props = {
        'input_identifier': result_name,
        'source_description': f"ConnectedSum({k1_name}, {k2_name})",
        'knot_atlas_name': result_name,
        'components': 1,
        'stability_heuristic': 'Composite',
        'is_alternating': None, # Alternating property not guaranteed
        'is_torus': False, # Connected sum of non-trivial knots is not torus
        'is_fibered': None, # Fibered property is complex for sums
        'volume': 0.0, # Volume IS additive for connected sum IF defined as sum of volumes of complements (which is 0 for prime knots)
        'log_abs_determinant': None, # Recalculate below
        # Properties needing interaction model
        'framing_number': 'UNKNOWN',
        'topological_charge_Q': 'UNKNOWN',
        'dynamic_stiffness_k': 'UNKNOWN',
        'effective_inertia_m_eff': 'UNKNOWN',
    }

    # --- Properties that add ---
    sig1 = knot_calc1.get_property('signature')
    sig2 = knot_calc2.get_property('signature')
    if sig1 is not None and sig2 is not None:
        result_props['signature'] = sig1 + sig2
    else: result_props['signature'] = None

    # Crossing Number: Min crossing number is additive for connected sums
    cn1 = knot_calc1.get_property('crossing_number_min')
    cn2 = knot_calc2.get_property('crossing_number_min')
    if cn1 is not None and cn2 is not None:
         result_props['crossing_number_min'] = cn1 + cn2
    else: result_props['crossing_number_min'] = None # If either is unknown

    # --- Properties that multiply ---
    det1 = knot_calc1.get_property('determinant')
    det2 = knot_calc2.get_property('determinant')
    if det1 is not None and det2 is not None:
        result_props['determinant'] = det1 * det2
        # Recalculate log_abs_determinant based on the product
        if result_props['determinant'] is not None and result_props['determinant'] > 0:
             result_props['log_abs_determinant'] = np.log(result_props['determinant'])
        elif result_props.get('determinant') == 0:
             result_props['log_abs_determinant'] = -np.inf
        else:
             result_props['log_abs_determinant'] = None # If determinant became None or negative (error?)
    else:
        result_props['determinant'] = None
        result_props['log_abs_determinant'] = None

    alex1_str = knot_calc1.get_property('alexander_poly')
    alex2_str = knot_calc2.get_property('alexander_poly')
    # Ensure both are strings and seem like valid polynomials before trying Sage conversion
    valid_poly_strs = True
    if not isinstance(alex1_str, str) or not alex1_str or ' ' in alex1_str.strip(): # Basic checks
        valid_poly_strs = False
    if not isinstance(alex2_str, str) or not alex2_str or ' ' in alex2_str.strip():
        valid_poly_strs = False

    if valid_poly_strs and SAGE_AVAILABLE and t:
        try:
            # Need to parse string back to Sage polynomial using the correct ring T
            p1 = T(alex1_str)
            p2 = T(alex2_str)
            p_prod = p1 * p2
            result_props['alexander_poly'] = str(p_prod)
            # Recalculate evaluations
            try:
                val_neg1 = p_prod(-1)
                result_props['alex_at_neg1'] = abs(int(val_neg1)) if hasattr(val_neg1, 'is_integer') and val_neg1.is_integer() else abs(float(val_neg1))
            except Exception as e_alex1_sum:
                print(f"Warn: Alex(-1) eval failed for connected sum: {e_alex1_sum}")
                result_props['alex_at_neg1'] = None
            try:
                val_neg2 = p_prod(-2)
                result_props['alex_at_neg2'] = abs(int(val_neg2)) if hasattr(val_neg2, 'is_integer') and val_neg2.is_integer() else abs(float(val_neg2))
            except Exception as e_alex2_sum:
                print(f"Warn: Alex(-2) eval failed for connected sum: {e_alex2_sum}")
                result_props['alex_at_neg2'] = None
        except Exception as e_alex_sum:
            print(f"Warn: Failed to compute Alexander polynomial for connected sum ({alex1_str}, {alex2_str}): {e_alex_sum}")
            result_props['alexander_poly'] = None
            result_props['alex_at_neg1'] = None
            result_props['alex_at_neg2'] = None
    else:
        result_props['alexander_poly'] = None # Cannot calculate if Sage unavailable or polys missing/invalid
        result_props['alex_at_neg1'] = None
        result_props['alex_at_neg2'] = None

    # --- Properties that don't combine simply ---
    result_props['jones_poly'] = 'UNKNOWN (Non-multiplicative)'
    result_props['jones_at_roots'] = {} # Cannot easily combine
    result_props['log_abs_jones_at_roots'] = {}

    # Chirality: Sum is chiral if either component is chiral
    # (Sum is amphichiral only if BOTH components are amphichiral)
    chiral1 = knot_calc1.get_property('is_chiral')
    chiral2 = knot_calc2.get_property('is_chiral')
    if chiral1 is None or chiral2 is None:
        result_props['is_chiral'] = None # Unknown if either is unknown
    else:
        result_props['is_chiral'] = chiral1 or chiral2

    print("  Resulting Properties (estimated):")
    # Use the report formatting logic for consistency (simplified here)
    for key, value in sorted(result_props.items()):
         if key in ['framing_number', 'topological_charge_Q', 'dynamic_stiffness_k', 'effective_inertia_m_eff']: continue # Skip placeholders
         if isinstance(value, float) or isinstance(value, np.floating):
              if np.isinf(value):
                  print(f"    {key:<22}: {value}")
              else:
                  print(f"    {key:<22}: {value:.5f}")
         elif isinstance(value, dict) and not value:
              print(f"    {key:<22}: {{}}") # Empty dict
         elif isinstance(value, dict):
             print(f"    {key:<22}:")
             for k, v in sorted(value.items()):
                 if isinstance(v, float) or isinstance(v, np.floating):
                     if np.isinf(v):
                         print(f"      {k}: {v}")
                     else:
                         print(f"      {k}: {v:.5f}")
                 else:
                     print(f"      {k}: {v}")
         elif isinstance(value, str) and len(value) > 60:
             print(f"    {key:<22}: {value[:57]}...")
         else:
              print(f"    {key:<22}: {value}")
    print("-" * 35)

    # Return the dictionary of properties. We don't create a full KnotPropertyCalculator
    # as we lack the underlying geometric object (Link/Knot) for the sum.
    return result_props

# --- Braid Multiplication --- #
def multiply_braids(knot_calc1, knot_calc2):
    """
    Performs braid multiplication conceptually and calculates invariants of the result.
    Takes two KnotPropertyCalculator objects, assumes they have braid representations,
    concatenates their braid words, and creates a new KnotPropertyCalculator for the closure.

    LIMITATIONS (Physical Context):
    - Operation Definition: Concatenates specific braid representations. The result *highly depends*
      on the chosen braid words 'b1', 'b2' (and their braid index 'n') for the input knots.
    - Physical Meaning: Its interpretation as a physical "collision" or "interaction" is unclear
      and likely inaccurate. It doesn't model forces, energy exchange, or dynamics.
    - Framing (f): Ignores the physical framing state of the initial braids and the resulting closed loop.
    - Outcome Complexity: Often results in complex Links or the Unknot, which may not reflect
      simple physical interactions (e.g., scattering, simple decay).
    - Provides a way to generate new topologies from braid structure but is not a robust model
      of physical particle interactions. Useful for exploring braid group structure effects.
    """
    k1_name = knot_calc1.get_property('knot_atlas_name') or knot_calc1.identifier
    k2_name = knot_calc2.get_property('knot_atlas_name') or knot_calc2.identifier
    print(f"\n--- Calculating Braid Product: ({k1_name}) * ({k2_name}) ---")

    # Get braid words
    braid1 = knot_calc1.get_property('braid_word_repr')
    braid2 = knot_calc2.get_property('braid_word_repr')

    if braid1 is None or braid2 is None:
        print(f"ERROR: Cannot multiply braids. Missing braid representation for {k1_name} or {k2_name}.")
        return None

    # Ensure they are tuples of integers
    try:
        braid1 = tuple(int(x) for x in braid1)
        braid2 = tuple(int(x) for x in braid2)
    except (TypeError, ValueError) as e:
         print(f"ERROR: Braid words must be sequences of integers. Found: {braid1}, {braid2}. Error: {e}")
         return None

    # Concatenate braid words (tuples)
    combined_braid_word = braid1 + braid2

    # Check if the combined braid is trivial (e.g., empty tuple)
    if not combined_braid_word:
        print("Info: Combined braid word is empty. Result is Unknot.")
        # Return a pre-calculated unknot object if available, or create one
        # For simplicity, create one on the fly (might duplicate calculation if 0_1 is already done)
        return KnotPropertyCalculator('0_1', source_description=f"BraidProduct({k1_name}, {k2_name}) -> TrivialBraid")

    print(f"  Combined Braid Word: {combined_braid_word}")
    # Create a new KnotPropertyCalculator for the resulting closed braid
    # The identifier IS the braid word tuple
    try:
        result_calculator = KnotPropertyCalculator(combined_braid_word,
                                                   source_description=f"BraidProduct({k1_name}, {k2_name})")
        return result_calculator
    except Exception as e:
        print(f"ERROR: Failed to create/analyze knot from combined braid {combined_braid_word}: {e}")
        return None

# --- Combination Analysis Function --- #
def analyze_combinations(knot_calculators_dict):
    """
    Iterates through pairs of knots in the dictionary and analyzes their
    connected sum (conceptual) and braid product (generating a new object).
    """
    print("\n" + "="*20 + " Analyzing Knot Combinations " + "="*20)
    if not knot_calculators_dict:
         print("Warning: No knot calculators provided to analyze_combinations.")
         return {}

    # Ensure all values are KnotPropertyCalculator instances
    valid_calculators = {name: calc for name, calc in knot_calculators_dict.items() if isinstance(calc, KnotPropertyCalculator)}
    if len(valid_calculators) != len(knot_calculators_dict):
         print("Warning: Some items in knot_calculators_dict were not KnotPropertyCalculator instances.")

    names = sorted([name for name in valid_calculators if name != '0_1']) # Exclude unknot
    if not names:
         print("No non-unknot calculators to analyze.")
         return {}

    analyzed_pairs = set()
    combination_results = {}

    for i in range(len(names)):
        for j in range(i, len(names)): # Include self-combinations like 3_1 # 3_1
            name1 = names[i]
            name2 = names[j]

            # Avoid duplicate pairs in reporting if order doesn't matter conceptually
            # (though braid product IS ordered)
            # pair = tuple(sorted((name1, name2)))
            # if pair in analyzed_pairs: continue
            # analyzed_pairs.add(pair)

            print(f"\n--- Analyzing Combination: {name1} and {name2} ---")
            calc1 = valid_calculators[name1]
            calc2 = valid_calculators[name2]

            # 1. Conceptual Connected Sum
            connected_sum_props = connected_sum(calc1, calc2)
            if connected_sum_props:
                 combination_results[(name1, '#', name2)] = connected_sum_props
            # (Reporting is handled within connected_sum)

            # 2. Braid Multiplication (Order matters: calc1 * calc2)
            braid_product_calc = multiply_braids(calc1, calc2)
            if braid_product_calc:
                braid_product_calc.report()
                # Store results - use calculator object itself
                combination_results[(name1, '*B', name2)] = braid_product_calc

            print("-" * 40) # Separator between pairs
    return combination_results

# --- main_analysis.py ---
# Main script to calculate properties and explore

# Define placeholder targets for C1 fit (replace with actual values)
C1_REQUIRED_TARGETS = {
    "electron": 1.0,  # Example value
    "muon": 1.5,      # Example value
    "tau": 2.0,       # Example value
}

if __name__ == "__main__":
    print("\n" + "="*20 + " LSC Knot Property Analysis Engine " + "="*20)

    # --- Phase 1: Calculate Properties of Base Knots ---
    print("\n--- PHASE 1: Calculating Invariants for Base Knots ---")
    # Analyze first ~10 knots (up to 6 crossings) + unknot
    base_knots_to_analyze = [
        "0_1", "3_1", "4_1", "5_1", "5_2",
        "6_1", "6_2", "6_3", # Knots with 6 crossings
        "7_1", "7_2", "7_3", "7_4" # Knots with 7 crossings (first few)
        # Add more standard knot names here as needed
    ]
    knot_calculators = {}
    for name in base_knots_to_analyze:
        print(f"\nCalculating properties for: {name}")
        try:
            calculator = KnotPropertyCalculator(name, source_description="Known Atlas Knot")
            knot_calculators[name] = calculator
            calculator.report()
        except Exception as e_init:
             print(f"ERROR: Failed to initialize or report KnotPropertyCalculator for {name}: {e_init}")
             # Add a placeholder or skip?
             knot_calculators[name] = None # Indicate failure

    # Filter out failed initializations before combination analysis
    successful_calculators = {name: calc for name, calc in knot_calculators.items() if calc is not None}

    # --- Phase 2: Analyze Knot Combinations ---
    combination_results = analyze_combinations(successful_calculators)

    # --- Phase 3: Data Analysis for Physics Mapping (Example) ---
    print("\n--- PHASE 3: Data Ready for Physics Correlation ---")
    print("Invariant data calculated and stored in 'knot_calculators' dictionary (base knots) and 'combination_results' (sums/products).")
    print("NOTE: Interaction results ('combination_results') are based on simplified mathematical operations (see function comments). `multiply_braids` depends on input braid representation, `connected_sum` does not.")
    print("FUTURE WORK: Generate properties for different braid representations (States: K,n,b) of the same knot K up to L_max to explore potential excited states.")

    # --- LSC Interpretation Context ---
    # The assignment of particles (like electron=3_1) implies these specific knots
    # represent the stable ground states. In LSC, this stability arises because:
    # 1. Energy Minimization: They correspond to minima in a dynamic potential V(x, f)
    #    that includes framing (f). Minimal framing states (|f|=1/2 for fermions) are lowest energy.
    # 2. Decay Channels: Excited states (higher |f| or more complex braids for the same knot type)
    #    are assumed unstable and decay rapidly to ground states, often via emission of gauge bosons
    #    (like photons, represented as spin-1 geometric ripples carrying away excess energy/twist).
    # This explains the "particle desert" - the lack of observed stable excited states for fundamental particles.
    # --- End LSC Context ---

    # Example: Extract data needed for c1 fit (as done in previous script)
    leptons_assigned = {"electron": "3_1", "muon": "5_1", "tau": "5_2"}
    print("\nData for Lepton Candidates (e=3_1, mu=5_1, tau=5_2):")
    fit_data = {}
    for lepton, knot_name in leptons_assigned.items():
        if knot_name in successful_calculators:
             calc = successful_calculators[knot_name]
             target_c1 = C1_REQUIRED_TARGETS.get(lepton) # Get target value

             # Extract specific invariants needed for c1 fit
             # Use .get() with default None for safety if a property wasn't calculated
             log_det_val = calc.get_property('log_abs_determinant')
             sig_val = calc.get_property('signature')
             jones_w5_logabs_dict = calc.get_property('log_abs_jones_at_roots')
             jones_w5_val = None
             if isinstance(jones_w5_logabs_dict, dict):
                 jones_w5_val = jones_w5_logabs_dict.get('w5')

             alex_neg1_val = calc.get_property('alex_at_neg1')

             data_pt = {
                 'req_c1': target_c1,
                 'log_det': log_det_val,
                 'sig': sig_val,
                 'jones_w5_logabs': jones_w5_val,
                 'alex_neg1': alex_neg1_val
             }
             fit_data[knot_name] = data_pt

             # Format output nicely, handling None values
             log_det_str = f"{log_det_val:.3f}" if isinstance(log_det_val, (int, float)) and np.isfinite(log_det_val) else ('-inf' if log_det_val == -np.inf else 'N/A')
             sig_str = f"{sig_val}" if sig_val is not None else 'N/A'
             # Use -log|J(w5)| = - jones_w5_val (since it's already logabs)
             jones_str = f"{-jones_w5_val:.3f}" if isinstance(jones_w5_val, (int, float)) and np.isfinite(jones_w5_val) else ('inf' if jones_w5_val == -np.inf else 'N/A')
             alex_str = f"{alex_neg1_val}" if alex_neg1_val is not None else 'N/A'
             req_c1_str = f"{target_c1:.3f}" if target_c1 is not None else 'N/A'

             print(f"  {knot_name}: Req_c1={req_c1_str}, log|Det|={log_det_str}, Sig={sig_str}, "\
                   f"-log|J(ω5)|={jones_str}, |Δ(-1)|={alex_str}")
        else:
             print(f"  {knot_name}: Data not calculated or failed initialization.")

    # Here, one would import the fitting functions and run the correlation
    # analysis on the 'fit_data' dictionary as performed in the previous script.
    # Example: from your_fitting_module import perform_linear_fit
    # Example: fit_result = perform_linear_fit(fit_data)
    # print(f"\nFit Result: {fit_result}")
    print("\n>>> Analysis can now proceed using the calculated invariants <<<")

    print("\n--- Analysis Engine Finished ---")